<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>风廓线</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* 隐藏body窗口区域滚动条 */
        }

    </style>


    <script type="text/javascript" src="js/jquery/jquery-2.1.1.min.js"></script>

    <link href="js/colorpicker/css/colorpicker.css" rel="stylesheet" />

    <script src="js/colorpicker/colorpicker.js"></script>
    <script type="text/javascript" src="js/layui/layui.all.js"></script>
    <link rel="stylesheet" href="js/layui/css/layui.css"  media="all">
    <script type="text/javascript" src="js/layer3.0/layer.js"></script>




    <script type="importmap">
      {
        "imports": {
          "three": "/three.js-r139/build/three.module.js",
          "IFCLoader":"/three.js-r139/examples/jsm/loaders/IFCLoader.js"
        }
      }
    </script>

    <script type="module"  src="./windy3DModule.js"></script>
    <link rel="stylesheet" href="css/style.css">
    <script type="text/javascript">
        var windy=null;
        var grid=null;

        //网页FPS监控--------不需要去掉就行了
        var showFPS = (function () {
            //requestAnimationFrame 函数兼容设计
            var requestAnimationFrame =
                window.requestAnimationFrame || //Chromium
                window.webkitRequestAnimationFrame || //Webkit
                window.mozRequestAnimationFrame || //Mozilla Geko
                window.oRequestAnimationFrame || //Opera Presto
                window.msRequestAnimationFrame || //IE Trident?
                function (callback) { //Fallback function
                    window.setTimeout(callback, 1000 / 60);
                };

            var fps = 0,offset;
            var lastTime = Date.now();
            function calcFPS() {
                offset = Date.now() - lastTime;
                fps += 1;
                if (offset >= 1000) {
                    lastTime += offset;
                    displayFPS(fps);
                    fps = 0;
                }
                requestAnimationFrame(calcFPS);
            };
            function displayFPS(fps) {
                if(fps>60){
                    fps = 60;
                }
                var fpsStr = fps + ' FPS';
                $('#fpsdiv').html(fpsStr);
            }
            return function () {
                calcFPS();
            };
        })();
        showFPS();
    </script>


</head>
<body>
    <div id="canvas-frame"></div>
    <div id='fpsdiv'>FPS获取中</div>
    <div id='paramsDiv'>

        <div class='windycanvas_row'>
            <div class='name'>粒子个数：</div>
            <div class='slidercont'>
                <div id='windy_count' class='sliderbaritem'></div>
            </div>
        </div>
        <div class='windycanvas_row'>
            <div class='name'>渲染层数：</div>
            <div class='slidercont'>
                <div id='windy_layers' class='sliderbaritem'></div>
            </div>
        </div>
        <div class='windycanvas_row'>
            <div class='name'>线长度：</div>
            <div class='slidercont'>
                <div id='windy_length' class='sliderbaritem'></div>
            </div>
        </div>
        <div class='windycanvas_row'>
            <div class='name'>线宽度：</div>
            <div class='slidercont'>
                <div id='windy_linewidth' class='sliderbaritem'></div>
            </div>
        </div>
        <div class='windycanvas_row'>
            <div class='name'>移动速率：</div>
            <div class='slidercont'>
                <div id='windy_speed' class='sliderbaritem'></div>
            </div>
        </div>
        <div class='windycanvas_row'>
            <div class='name'>存活时间：</div>
            <div class='slidercont'>
                <div id='windy_age' class='sliderbaritem'></div>
            </div>
        </div>
        <div class='windycanvas_row'>
            <div class='windycanvas_formcont'>
                <span class='windycanvas_span'>颜色：</span>
                <input id="point_color" value="#ebb14c" class="windycanvas_formitem windycanvas_picker" readonly>
                <div class='windycanvas_colorpanelbg' style='background-color:#ebb14c'></div>
            </div>
        </div>
<!--        <div class='windycanvas_row'>-->
<!--            <div class='extentWindy' data-type='world'>世界范围</div>-->
<!--            <div class='extentWindy' data-type='china'>中国范围</div>-->
<!--        </div>-->
<!--        <div class='windycanvas_row'>-->
<!--            <div class='resizeSize' data-type='1'>全屏</div>-->
<!--            <div class='resizeSize' data-type='2'>1000*600</div>-->
<!--            <div class='resizeSize' data-type='3'>随机尺寸</div>-->
<!--        </div>-->
    </div>
    <script id="vertexShader" type="x-shader/x-vertex">
            varying vec2 vUv;
            uniform float u_time;
            attribute float aIndex;

            uniform float speed;
            uniform float max_age;
            uniform float start_time;
            uniform float uSize;
            uniform float length;
            uniform float points_number;
            varying float vSize;
            varying float opacity;
            void main()
            {
                highp float start_point=(u_time-start_time)*speed;
                highp float end_point = start_point+length;
                vUv = uv;
                //opacity=percent;
                float size = uSize;
                float newStartTime = 0.0;
                float newStartIndex = 0.0;
                float i=0.0;
                float index = mod(aIndex , points_number);
                // 根据时间确定当前飞线的位置， 以结束点为准
                    float currentEnd =mod(points_number * ((u_time) * speed),points_number);//points_number* mod(u_time-start_time,points_number/speed) * speed;// //
                    //float currentEnd2 = clamp(currentEnd-length-20.0,0.0,points_number);
                    if(currentEnd-length+1.0<0.0) { //当前飞线结束点回到左边，还剩一部分在右边
                        if(aIndex<=currentEnd){
                            // 设置渐变的尺寸，头大尾小
                            float sizePct = (length - (currentEnd - aIndex)) / length;
                            size *= sizePct;
                            opacity = 1.0;
                        }else if(aIndex>=(currentEnd+points_number-length+1.0)){
                            float sizePct = (length - (currentEnd +points_number - aIndex)) / length;
                            size *= sizePct;
                            opacity = 1.0;
                        }else{
                        opacity=0.0;}

                    }else{
                        // 判断当前像素点是否在飞线范围内，如果在范围内设置尺寸和透明度
                        if (aIndex <= currentEnd && aIndex > currentEnd - length) {
                            // 设置渐变的尺寸，头大尾小
                            float sizePct = (length - (currentEnd - aIndex)) / length;
                            size *= sizePct;
                            opacity = 1.0;
                        } else {
                            opacity = 0.0;
                        }
                    }
                    // 设置点的大小
                    gl_PointSize = size * 0.4;

                vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                gl_Position = projectionMatrix * mvPosition;
            }
          </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
                    #ifdef GL_ES
            //precision mediump float;
            #endif
            uniform vec3 color;
            varying float vSize;
            uniform float points_number;
            varying float opacity;
            void main(){

                gl_FragColor = vec4(color,opacity);

            }
          </script>
</body>
</html>

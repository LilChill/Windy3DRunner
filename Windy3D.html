<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>风廓线</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* 隐藏body窗口区域滚动条 */
        }

    </style>


    <script type="text/javascript" src="js/jquery/jquery-2.1.1.min.js"></script>

    <link href="js/colorpicker/css/colorpicker.css" rel="stylesheet" />
    <link rel="stylesheet" href="css/style.css">
    <script src="js/colorpicker/colorpicker.js"></script>
    <script type="text/javascript" src="js/layui/layui.all.js"></script>
    <link rel="stylesheet" href="js/layui/css/layui.css"  media="all">
    <script type="text/javascript" src="js/layer3.0/layer.js"></script>




    <script type="importmap">
      {
        "imports": {
          "three": "/three.js-r139/build/three.module.js",
          "IFCLoader":"/three.js-r139/examples/jsm/loaders/IFCLoader.js"
        }
      }
    </script>

    <script type="module"  src="./windy3DModule.js"></script>
    <script type="text/javascript">

        //网页FPS监控--------不需要去掉就行了
        var showFPS = (function () {
            //requestAnimationFrame 函数兼容设计
            var requestAnimationFrame =
                window.requestAnimationFrame || //Chromium
                window.webkitRequestAnimationFrame || //Webkit
                window.mozRequestAnimationFrame || //Mozilla Geko
                window.oRequestAnimationFrame || //Opera Presto
                window.msRequestAnimationFrame || //IE Trident?
                function (callback) { //Fallback function
                    window.setTimeout(callback, 1000 / 60);
                };

            var fps = 0,offset;
            var lastTime = Date.now();
            function calcFPS() {
                offset = Date.now() - lastTime;
                fps += 1;
                if (offset >= 1000) {
                    lastTime += offset;
                    displayFPS(fps);
                    fps = 0;
                }
                requestAnimationFrame(calcFPS);
            };
            function displayFPS(fps) {
                if(fps>60){
                    fps = 60;
                }
                var fpsStr = fps + ' FPS';
                $('#fpsdiv').html(fpsStr);
            }
            return function () {
                calcFPS();
            };
        })();
        showFPS();
    </script>


</head>
<body>
    <div id="canvas-frame"></div>
    <div id='fpsdiv'>FPS获取中</div>

    <script id="vertexShader" type="x-shader/x-vertex">
            varying vec2 vUv;
            uniform float u_time;
            attribute float aIndex;

            uniform float speed;
            uniform float max_age;
            uniform float start_time;
            uniform float uSize;
            uniform float length;
            uniform float points_number;
            varying float vSize;
            varying float opacity;
            void main()
            {
                highp float start_point=(u_time-start_time)*speed;
                highp float end_point = start_point+length;
                vUv = uv;
                //opacity=percent;
                float size = uSize;
                float newStartTime = 0.0;
                float newStartIndex = 0.0;
                float i=0.0;
                float index = mod(aIndex , points_number);
                // 根据时间确定当前飞线的位置， 以结束点为准
                    float currentEnd =points_number * fract((u_time-newStartTime) * speed);//points_number* mod(u_time-start_time,points_number/speed) * speed;// //
                    if(currentEnd-length>=points_number) {
                        i+=1.0;
                        opacity =0.0;
                        currentEnd=0.0;
                        newStartTime = u_time;
                        newStartIndex += i*points_number;
                    }
                    else{
                        // 判断当前像素点是否在飞线范围内，如果在范围内设置尺寸和透明度
                        if (aIndex < currentEnd && aIndex > currentEnd - length) {
                            // 设置渐变的尺寸，头大尾小
                            float sizePct = (length - (currentEnd - aIndex)) / length;
                            size *= sizePct;
                            opacity = 1.0;
                        } else {
                            opacity = 0.0;
                        }
                    }


                    // 设置点的大小
                    gl_PointSize = size * 0.4;

                vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                gl_Position = projectionMatrix * mvPosition;
            }
          </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
                    #ifdef GL_ES
            //precision mediump float;
            #endif
            uniform vec3 color;
            varying float vSize;
            uniform float points_number;
            varying float opacity;
            void main(){

                gl_FragColor = vec4(color,opacity);

            }
          </script>
</body>
</html>
